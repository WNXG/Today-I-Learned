# JavaScript模块化

> 什么是模块化开发?
事实上模块化开发最终的目的是将程序划分成一个个小的结构； 这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构；这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用；也可以通过某种方式，导入另外结构中的变量、函数、对象等；
上面说提到的结构，就是模块；按照这种结构划分开发程序的过程，就是模块化开发的过程；

无论你多么喜欢JavaScript，以及它现在发展的有多好，我们都需要承认在Brendan Eich用了10天写出JavaScript的时候，
它都有很多的缺陷：
   - 比如var定义的变量作用域问题；
   - 比如JavaScript的面向对象并不能像常规面向对象语言一样使用class； 
   - 比如JavaScript没有模块化的问题；
 Brendan Eich本人也多次承认过JavaScript设计之初的缺陷，但是随着JavaScript的发展以及标准化，存在的缺陷问题基
本都得到了完善。无论是web、移动端、小程序端、服务器端、桌面应用都被广泛的使用；

早期的JavaScript
 在网页开发的早期，Brendan Eich开发JavaScript仅仅作为一种脚本语言，做一些简单的表单验证或动画实现等，那个时
候代码还是很少的：
 这个时候我们只需要讲JavaScript代码写到<script>标签中即可；
 并没有必要放到多个文件中来编写；甚至流行：通常来说 JavaScript 程序的长度只有一行。 
> 但是随着前端和JavaScript的快速发展，JavaScript代码变得越来越复杂了：
ajax的出现，前后端开发分离，意味着后端返回数据后，我们需要通过JavaScript进行前端页面的渲染； 
SPA的出现，前端页面变得更加复杂：包括前端路由、状态管理等等一系列复杂的需求需要通过JavaScript来实现；
包括Node的实现，JavaScript编写复杂的后端程序，没有模块化是致命的硬伤； 

所以，模块化已经是JavaScript一个非常迫切的需求：但是JavaScript本身，直到ES6（2015）才推出了自己的模块化方案； 在此之前，为了让JavaScript支持模块化，涌现出了很多不同的模块化规范：AMD、CMD、CommonJS等

> 早期没有模块化带来了很多的问题：比如命名冲突的问题

当然，我们有办法可以解决上面的问题：立即函数调用表达式（IIFE）
IIFE (Immediately Invoked Function Expression)

但是，我们其实带来了新的问题：
第一，我必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用；
第二，代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写；
第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况

所以，我们会发现，虽然实现了模块化，但是我们的实现过于简单，并且是没有规范的。

我们需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码；
这个规范中应该包括核心功能：模块本身可以导出暴露的属性，模块又可以导入自己需要的属性；
JavaScript社区为了解决上面的问题，涌现出一系列好用的规范，接下来我们就学习具有代表性的一些规范。


## CommonJS和Node
我们需要知道CommonJS是一个规范，最初提出来是在浏览器以外的地方使用，并且当时被命名为ServerJS，后来为了
体现它的广泛性，修改为CommonJS，平时我们也会简称为CJS。  
- Node是CommonJS在服务器端一个具有代表性的实现；
- Browserify是CommonJS在浏览器中的一种实现；
- webpack打包工具具备对CommonJS的支持和转换； 
所以，Node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发：

在Node中每一个js文件都是一个单独的模块；
这个模块中包括CommonJS规范的核心变量：exports、module.exports、require； 
我们可以使用这些变量来方便的进行模块化开发； 
前面我们提到过模块化的核心是导出和导入，Node中对其进行了实现：
> exports和module.exports可以负责对模块中的内容进行导出； 
> require函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；

### exports导出
> 注意：exports是一个对象，我们可以在这个对象中添加很多个属性，添加的属性会导出；

**意味着main中的bar变量等于exports对象**；也就是require通过各种查找方式，最终找到了exports这个对象；并且将这个exports对象赋值给了bar变量；bar变量就是exports对象了；
bar对象是exports对象的浅拷贝（引用赋值）；
浅拷贝的本质就是一种引用的赋值而已；

理解对象的引用赋值:即 内存地址指向同一个地址

**它们实际上是一个浅层拷贝**

Node中我们经常导出东西的时候，又是通过module.exports导出的：
> module.exports和exports有什么关系或者区别呢？

通过维基百科中对CommonJS规范的解析：CommonJS中是没有module.exports的概念的；但是为了实现模块的导出，Node中使用的是Module的类，每一个模块都是Module的一个实例，也就是
module；所以在Node中真正用于导出的其实根本不是exports，而是module.exports;因为module才是导出的真正实现者；

但是，为什么exports也可以导出呢？
    这是因为module对象的exports属性是exports对象的一个引用；也就是说 module.exports = exports = main中的bar；

**require是一个函数，可以帮助我们引入一个文件（模块）中导入的对象。**

require的查找规则
> https://nodejs.org/dist/latest-v14.x/docs/api/modules.html

#### 模块的加载过程
结论一：模块在被第一次引入时，模块中的js代码会被运行一次
结论二：模块被多次引入时，会缓存，最终只加载（运行）一次
        为什么只会加载运行一次呢？这是因为每个模块对象module都有一个属性：loaded。  为false表示还没有加载，为true表示已经加载
结论三：如果有循环引入，那么加载顺序是什么？

图结构在遍历的过程中，有深度优先搜索（DFS, depth first search）和广度优先搜索（BFS, breadth first 
search）；
**Node采用的是深度优先算法**

### CommonJS规范缺点
CommonJS加载模块是同步的：同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行；这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快；
如果将它应用于浏览器呢？浏览器加载js文件需要先从服务器将文件下载下来，之后在加载运行；那么采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作；
所以在浏览器中，我们通常不使用CommonJS规范：当然在webpack中使用CommonJS是另外一回事；因为它会将我们的代码转成浏览器可以直接执行的代码；
在早期为了可以在浏览器中使用模块化，通常会采用AMD或CMD：但是目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者
ES Module代码的转换；AMD和CMD已经使用非常少了。





# Node常用内置模块
## 内置模块path
> path模块用于对路径和文件进行处理，提供了很多好用的方法。

path常见的API

## 内置模块fs
> fs是File System的缩写，表示文件系统。

fs的API介绍

文件描述符

文件的读写

flag选项

encoding选项

文件夹操作
1.新建一个文件夹
> 使用fs.mkdir()或fs.mkdirSync()创建一个新文件夹

2.获取文件夹的内容
3.文件重命名

文件夹的复制



## events模块
    Node中的核心API都是基于异步事件驱动的：
    在这个体系中，某些对象（发射器（Emitters））发出某一个
事件；我们可以监听这个事件（监听器 Listeners），并且传入的回
调函数，这个回调函数会在监听到事件时调用；

发出事件和监听事件都是通过EventEmitter类来完成的，它们都属
于events对象。
emitter.on(eventName, listener)：监听事件，也可以使用
addListener；
emitter.off(eventName, listener)：移除事件监听，也可以使
用removeListener； 
emitter.emit(eventName[, ...args])：发出事件，可以携带一
些参数；

- 常见的属性
> EventEmitter的实例有一些属性，可以记录一些信息： 
    emitter.eventNames()：返回当前 EventEmitter对象注册的事件字符串数组； p emitter.getMaxListeners()：返回当前 EventEmitter对象的最大监听器数量，可以通过setMaxListeners()
来修改，默认是10； 
    emitter.listenerCount(事件名称)：返回当前 EventEmitter对象某一个事件名称，监听器的个数；
    emitter.listeners(事件名称)：返回当前 EventEmitter对象某个事件监听器上所有的监听器数组；

- 方法的补充
    emitter.once(eventName, listener)：事件监听一次 emitter.prependListener()：将监听事件添加到最前面
    emitter.prependOnceListener()：将监听事件添加到最前面，但是只监听一次 
    emitter.removeAllListeners([eventName])：移除所有的监听器